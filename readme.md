## 时间复杂度
特定算法处理规模为 n 的问题所需时间为 T(n)，大 O 表示法表示随着规模增大，算法执行时间 T(n) 的渐进增长速度。

大 O 表示法的计算有两个规则:
- 函数各项的常数系数可以忽略并等于 1
- 多项式中的低次项可以忽略，只保留高次项

## 冒泡排序
- 每一次循环比较相邻的两个元素，如果两个元素大小顺序与预期排序不符，就交换他们
- 一次循环完成后，最大或最小（取决于升序降序以及遍历开始位置）的元素一定已经就位
- 重复进行遍历，长度为 n 的数组经过 n - 1 次遍历，所有元素必然就位

时间复杂度：最坏的情况下，每一次比较都要交换元素位置，时间复杂度为 O(n<sup>2</sup>)

稳定性：冒泡排序中两个元素交换位置的唯一情况就是 arr[i + 1] >(或<) arr[i]，相等的元素并不会交换位置，所以冒泡排序是稳定的

## 插入排序
把数组中的数据分为两个区间，已排序区间和未排序区间。
核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一致有序。
- 初始已排序区间只有一个元素，就是数组的第一个元素
- 未排序区间中的每一个元素，和已排序区间的元素依次比较大小，找到合适的插入位置
- 找到插入点之后，还需要把插入点之后的元素顺序往后移动一位

在插入排序过程中，移动操作的次数总是固定的，等于**逆序度**。
时间复杂度：对于插入排序还说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，O(n²)。
稳定性：在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，就可以保持原有的顺序不变，所以插入排序是稳定的。


## 选择排序（简单）
把数组中的数据分为两个区间，已排序区间和未排序区间。
- 遍历数组找到最小值（或最大值，取决于升序降序）
- 将最小值与遍历数组的第一个元素交换，则数组已排序部分已有一个元素
- 对数组未排序部分重复上面操作，直至数组全部排序

时间复杂度：排序过程中总共对数组进行内外两层遍历，不过内部遍历的长度每次在减少。
O(n + (n - 1) + ... + 1) = O(( n + 1) * n / 2) = O(1/2 * n<sup>2</sup> + 1/2 * n) = O(1/2 * n<sup>2</sup>) = O(n<sup>2</sup>)

稳定性：简单选择排序中是取得的最小值（或最大值）与未排序部分第一个元素交换，原有相等的元素可能会因此改变相对顺序，所以简单选择排序是不稳定的。

## 归并排序
归并排序使用**分治思想**
- 把数组平均分为两部分
- 两部分分别进行排序（递归进行归并排序）
- 把排好序的两部分合并在一起

时间复杂度：归并排序的时间复杂度计算比较复杂，O(nlogn)，归并排序的执行效率和数组的有序程度无关，所以不管是最好情况、最快情况、平均情况时间复杂度都是 O(nlogn)
```
T(1) = C; // n = 1 时，常数时间，用 C 表示。
T(n) = 2 * T(n/2) + n;
T(n) = 2 * (2 * T(n/2²) + n/2) + n;
T(n) = 2 * (2 * (2 * T(n/2³) + n/4) + n/2) + n;
T(n) = 2 * (2² * T(n/2³) + n) + n;
T(n) = 2³ * T(n/2³) + 3n；
T(n) = 2ᵏ * T(n/2ᵏ) + kn；

// 当 T(n/2ᵏ) = T(1) 时
n/2ᵏ = 1;
k = log₂n;
// 代入公式
T(n) = n * C + nlog₂n
// 时间复杂度公式中 多项式中的低次项可以忽略，只保留高次项
T(n) = nlog₂n = nlogn(底数可省略)
```
稳定性：在合并的过程中，如果前后两部分有相同的元素，我们可以先把前半部分的元素放入临时数组中。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。

空间复杂度：由于在合并过程中需要用到额外的空间暂存数组，所以空间复杂度是 O(n)。

## 快速排序
快速排序也使用了**分治思想**
- 在数组下标 l 和下标 r 之间任取一个值作为参考值（下标为 m）
- 遍历 l 到 r 之间的值，把小于参考值的值放在左边（l - m-1），大于参考值的放在右边（m+1 - r），参考值放在中间（m）
- 对（l - m-1）和（m+1 - r）两部分递归进行快速排序
- 直到处理区间缩小为 1，就说明所有数据都有序了

时间复杂度：如果每次分区的时候正好可以把数组分为大小接近的两个区间，那快速排序的时间复杂度计算和归并排序一致。快速排序大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n²)。

空间复杂度：快速排序可以实现原地分区，所以空间复杂度是 O(1)，是原地排序算法。

稳定性：由于分区的过程涉及到交换操作，所以快速排序不是稳定排序算法。