## 时间复杂度
特定算法处理规模为 n 的问题所需时间为 T(n)，大 O 表示法表示随着规模增大，算法执行时间 T(n) 的渐进增长速度。

大 O 表示法的计算有两个规则:
- 函数各项的常数系数可以忽略并等于 1
- 多项式中的低次项可以忽略，只保留高次项

## 冒泡排序
- 每一次循环比较相邻的两个元素，如果两个元素大小顺序与预期排序不符，就交换他们
- 一次循环完成后，最大或最小（取决于升序降序以及遍历开始位置）的元素一定已经就位
- 重复进行遍历，长度为 n 的数组经过 n - 1 次遍历，所有元素必然就位

时间复杂度：最坏的情况下，每一次比较都要交换元素位置，时间复杂度为 O(n<sup>2</sup>)

稳定性：冒泡排序中两个元素交换位置的唯一情况就是 arr[i + 1] >(或<) arr[i]，相等的元素并不会交换位置，所以冒泡排序是稳定的

## 插入排序
把数组中的数据分为两个区间，已排序区间和未排序区间。
核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一致有序。
- 初始已排序区间只有一个元素，就是数组的第一个元素
- 未排序区间中的每一个元素，和已排序区间的元素依次比较大小，找到合适的插入位置
- 找到插入点之后，还需要把插入点之后的元素顺序往后移动一位

在插入排序过程中，移动操作的次数总是固定的，等于**逆序度**。
时间复杂度：对于插入排序还说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，O(n²)。
稳定性：在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，就可以保持原有的顺序不变，所以插入排序是稳定的。


## 选择排序（简单）
- 遍历数组找到最小值（或最大值，取决于升序降序）
- 将最小值与遍历数组的第一个元素交换，则数组已排序部分已有一个元素
- 对数组未排序部分重复上面操作，直至数组全部排序

时间复杂度：排序过程中总共对数组进行内外两层遍历，不过内部遍历的长度每次在减少。
O(n + (n - 1) + ... + 1) = O(( n + 1) * n / 2) = O(1/2 * n<sup>2</sup> + 1/2 * n) = O(1/2 * n<sup>2</sup>) = O(n<sup>2</sup>)

稳定性：简单选择排序中是取得的最小值（或最大值）与未排序部分第一个元素交换，原有相等的元素可能会因此改变相对顺序，所以简单选择排序是不稳定的。

